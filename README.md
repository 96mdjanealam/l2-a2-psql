# SQL এবং PostgreSQL সম্পর্কিত পাঁচটি তথ্য

## ১। LIMIT এবং OFFSET কেন ব্যবহার করা হয়?

### `LIMIT` কী?

`LIMIT` -এর মাধ্যমে আমরা কয়টা ডেটা দেখাবো সেটা বলে দিতে পারি।

উদাহরণ:

```sql
SELECT * FROM products
LIMIT 5;
```

হতে পারে `products` টেবিলে পাঁচের অধিক ডেটা রয়েছে তবে এখানে আমরা `products` টেবিল থেকে **শুধু ৫টা রেকর্ড (লাইন)** দেখতে পাবো।

---

### `OFFSET` কী?

`OFFSET` -এর মাধ্যমে শুরু থেকে কয়টা ডেটা বাদ দিতে হবে সেটা ঠিক করে দেওয়া হয়।

উদাহরণ:

```sql
SELECT * FROM products
OFFSET 10;
```

এখানে প্রথম **১০টা রেকর্ড বাদ** দিয়ে বাকি ডেটা দেখাবে।

---

### `LIMIT` আর `OFFSET` -এর একসাথে ব্যবহার:

এটা আমরা সাধারণত **pagination** -এর ক্ষেত্রে ব্যবহার করি।

উদাহরণ:

```sql
SELECT * FROM products
ORDER BY id
LIMIT 10 OFFSET 20;
```

ধরি আমরা তৃতীয় পেজ দেখছি, যেখানে প্রতি পেজে ১০টা করে ডেটা থাকে।

অর্থাৎ:
* **২০টা ডেটা বাদ** দিতে হবে (OFFSET 20),
* তারপর **১০টা ডেটা দেখাতে** হবে (LIMIT 10)।

---

## ২। `VARCHAR` আর `CHAR` ডেটা টাইপের মধ্যে পার্থক্য কি?

### `CHAR(n)` – **ফিক্সড দৈর্ঘ্যের স্ট্রিং**

এটা সবসময় **একই দৈর্ঘ্যের (n অক্ষরের)** জায়গা নেয়। যদি কম অক্ষর দেওয়া হয়, বাকি জায়গা **স্পেস (ফাঁকা) দিয়ে পূরণ করে**। এটা **ফিক্সড সাইজ ডেটা** রাখার জন্য ভালো।

উদাহরণ:

```sql
CHAR(5)
```

যদি আমরা `'Hi'` দেই, তাহলে এটা হয়ে যাবে `'Hi   '` (৩টা স্পেস যোগ হবে)। কিছু ক্ষেত্রে এটি ব্যবহার করা ভালো, যেমনঃ `'BD'`, `'USA'`, `'IND'` — দেশের কোডের মতো ডেটা।

---

### `VARCHAR(n)` – **ভ্যারিয়েবল দৈর্ঘ্যের স্ট্রিং**

এটা **সর্বোচ্চ `n` অক্ষর পর্যন্ত** রাখতে পারে। যত অক্ষর দেওয়া হয়, **ততটুকুই জায়গা নেয়**। বাড়তি স্পেস দেয় না। এটা **দৈর্ঘ্যে ভিন্ন রকম টেক্সট** রাখার জন্য বেশি সুবিধাজনক।

উদাহরণ:

```sql
VARCHAR(5)
```

* `'Hi'` দিলে সেটা **`Hi`-ই থাকবে**, কোনো স্পেস যোগ হবে না।
* `'Hello'` ঠিক আছে, কিন্তু `'Hello!'` দিলে (৬ অক্ষর) — **এরর দিবে**, কারণ ৫ অক্ষর ছিল সীমা।

---

## ৩। `SELECT` স্টেটমেন্টে `WHERE` ক্লজের কাজ কী?

`WHERE` ক্লজ ব্যবহার করা হয় **শর্ত অনুযায়ী ডেটা বের করার জন্য**।
যেমন ধরা যাক, আমি চাই- "সব ডেটা দরকার নেই, শুধু যেগুলো আমার শর্ত মেনে চলে, সেগুলোই দেখাও।"

---

### Syntax:

```sql
SELECT column_name
FROM table_name
WHERE condition;
```

---

### উদাহরণ:

ধরা যাক, একটা `students` টেবিল আছে।
আমি এখন শুধু **যেসব ছাত্রের বয়স ২০ বছর**, তাদের নাম দেখতে চাই।

```sql
SELECT name, age
FROM students
WHERE age = 20;
```

এই কুয়েরি শুধু তাদেরই দেখাবে, যাদের বয়স ২০ বছর।

এটি একটি বহুল ব্যবহৃত এবং গুরুত্বপূর্ণ ক্লজ। কিছু সাধারণ `WHERE` শর্ত:

| শর্ত         | উদাহরণ                            |
| ------------ | --------------------------------- |
| `=`          | `age = 25`                        |
| `>`          | `marks > 80`                      |
| `<`          | `price < 1000`                    |
| `!=` বা `<>` | `status != 'active'`              |
| `BETWEEN`    | `age BETWEEN 18 AND 25`           |
| `LIKE`       | `name LIKE 'A%'`                  |
| `IN`         | `city IN ('Dhaka', 'Chittagong')` |

---

## ৪। কিভাবে `UPDATE` স্টেটমেন্ট ব্যবহার করে ডেটা পরিবর্তন করা যায়?

`UPDATE` স্টেটমেন্ট দিয়ে আমরা টেবিলের ভেতরের **আগে থেকে থাকা ডেটা পরিবর্তন** করতে পারি।

---

### Syntax:

```sql
UPDATE table_name
SET column1 = value1, column2 = value2, ...
WHERE condition;
```

* `UPDATE` — কোন টেবিলের ডেটা আপডেট করবে।
* `SET` — কোন কলামে কী মান বসাবে।
* `WHERE` — কোন রো/তথ্যগুলো আপডেট করবে (খুব জরুরি! না দিলে সব রো বদলে যাবে)।

---

### উদাহরণ ১: এক কলাম আপডেট

ধরি, `employees` টেবিলে যেসব কর্মচারীর আইডি 5, তার বেতন পরিবর্তন করতে চাই:

```sql
UPDATE employees
SET salary = 50000
WHERE id = 5;
```

এটা শুধু **id = 5** এর বেতন আপডেট করবে।

---

### উদাহরণ ২: একাধিক কলাম আপডেট

```sql
UPDATE employees
SET salary = 60000, position = 'Senior Developer'
WHERE id = 7;
```

এটা **id = 7** এর বেতন ও পজিশন দুইটাই পরিবর্তন করবে।

---

### সতর্কতা:

* `WHERE` ক্লজ **দিতে ভুলা যাবে না**! না দিলে পুরো টেবিলের সব রো আপডেট হয়ে যাবে।

❌ ভুল:

```sql
UPDATE employees
SET salary = 70000;
```
এটা সব কর্মচারীর বেতন ৭০০০০ করে দেবে, যা সম্ভবত আমরা চাই না।

---

## ৫। `GROUP BY` কী এবং অ্যাগ্রিগেট অপারেশানে এর কাজ কী?

`GROUP BY` ক্লজ ব্যবহার করা হয় টেবিলের ডেটাগুলোকে **এক বা একাধিক কলামের ভিত্তিতে গ্রুপে ভাগ** করতে।
তারপর প্রতিটি গ্রুপের উপর অ্যাগ্রিগেট ফাংশন (যেমন `SUM()`, `COUNT()`, `AVG()`, `MAX()`, `MIN()`) চালানো হয়।

---

### যদি সহজভাবে চিন্তা করি:

"প্রতিটি বিভাগের কত জন কর্মচারী আছে?"
বা
"প্রতিটি প্রোডাক্ট ক্যাটাগরিতে মোট কত বিক্রি হয়েছে?"

তাহলে `GROUP BY` ব্যবহার করতে হবে।

---

### Syntax:

```sql
SELECT column_name, AGGREGATE_FUNCTION(column_name)
FROM table_name
GROUP BY column_name;
```

---

### উদাহরণ:

ধরি, `sales` নামে একটি টেবিল আছে:

| category | amount |
| -------- | ------ |
| Shoes    | 1000   |
| Shirts   | 1500   |
| Shoes    | 1200   |
| Shirts   | 800    |
| Hats     | 500    |

যদি আমি এখন প্রতিটি `category` অনুযায়ী মোট বিক্রি দেখতে চাই:

```sql
SELECT category, SUM(amount)
FROM sales
GROUP BY category;
```

**ফলাফল:**

| category | sum  |
| -------- | ---- |
| Shoes    | 2200 |
| Shirts   | 2300 |
| Hats     | 500  |

---

### ব্যবহারযোগ্য অ্যাগ্রিগেট ফাংশনসমূহ:

| ফাংশন     | কাজ               |
| --------- | ----------------- |
| `SUM()`   | মোট যোগফল         |
| `COUNT()` | মোট রেকর্ড সংখ্যা |
| `AVG()`   | গড় মান            |
| `MAX()`   | সর্বোচ্চ মান      |
| `MIN()`   | সর্বনিম্ন মান     |

---

### মনে রাখা প্রয়োজন:

* `GROUP BY` ছাড়া তুমি আলাদা আলাদা গ্রুপ অনুযায়ী হিসাব করা যায় না।
* সব `SELECT` করা কলাম হয় `GROUP BY` তে থাকতে হবে, নয়তো কোনো অ্যাগ্রিগেট ফাংশনের মধ্যে থাকতে হবে।
